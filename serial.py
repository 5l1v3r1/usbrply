#!/usr/bin/env python

from usbrply.printer import Printer, indented, indent_inc, indent_dec
from usbrply.pyprinter import bytes2AnonArray
import sys
import binascii
import json
import os

FTDI_DEVICE_OUT_REQTYPE = 64
# FTDI_DEVICE_IN_REQTYPE = 

req_s2i = {
    "RESET": 0,
    "SET_MODEM_CTRL": 1,
    "SET_FLOW_CTRL": 2,
    "SET_BAUDRATE": 3,
    "SET_DATA": 4,
    "POLL_MODEM_STATUS": 0x05,
    "SET_EVENT_CHAR": 0x06,
    "SET_ERROR_CHAR": 0x07,
    "SET_LATENCY_TIMER": 0x09,
    "GET_LATENCY_TIMER": 0x0A,
    "SET_BITMODE": 0x0B,
    "READ_PINS": 0x0C,
    "READ_EEPROM": 0x90,
    "WRITE_EEPROM": 0x91,
    "ERASE_EEPROM": 0x92,
}
req_i2s = dict([(v, k) for k, v in req_s2i.items()])

INTERFACE_ANY = 0
INTERFACE_A = 1
INTERFACE_B = 2
INTERFACE_C = 3
INTERFACE_D = 4


def interface_i2str(i):
    if i == INTERFACE_A:
        return "A"
    assert 0


def flags2map(s2i, vali):
    ret = {}
    for k, v in s2i.items():
        ret[k] = bool(vali & v)
    return ret


# is a packet json output format but a serial input format
class FT2232CParser(Printer):
    def __init__(self, args):
        Printer.__init__(self, args)
        self.ascii = args.ascii
        self.jo = []

    def next_json(self, j, prefix=None):
        self.jo.append(j)

    def header(self):
        # comment("Generated by usbrply-serial FT2232C")
        pass

    def footer(self):
        pass

    def handleControlWrite(self, d):
        print(d)
        if d['bRequestType'] != FTDI_DEVICE_OUT_REQTYPE:
            return
        request = req_i2s[d['bRequest']]
        print("bRequest", request)
        if request == "SET_FLOW_CTRL":
            assert d["wValue"] == 0
            interface = interface_i2str(d["wIndex"] & 0xFF)

            DISABLE_FLOW_CTRL = 0x0
            RTS_CTS_HS = (0x1 << 8)
            DTR_DSR_HS = (0x2 << 8)
            XON_XOFF_HS = (0x4 << 8)
            flag_s2i = {
                "DISABLE_FLOW_CTRL": DISABLE_FLOW_CTRL,
                "RTS_CTS_HS": RTS_CTS_HS,
                "DTR_DSR_HS": DTR_DSR_HS,
                "XON_XOFF_HS": XON_XOFF_HS,
            }
            flagmap = flags2map(flag_s2i, d["wIndex"] & 0xFF00)
            print("i%s SET_FLOW_CTRL: %s" % (interface, flagmap))
        elif request == "SET_DATA":
            parity = {
                0: "NONE",
                1: "ODD",
                2: "EVEN",
                3: "MARK",
                4: "SPACE",
            }[(d['wValue'] >> 8) & 0x7]

            stopbits = {
                0: "1",
                1: "15",
                2: "2",
            }[(d['wValue'] >> 11) & 0x3]

            breakon = {
                0: "OFF",
                1: "ON",
            }[(d['wValue'] >> 14) & 0x1]

            interface = interface_i2str(d["wIndex"])
            print("i%s SET_DATA: parity %s, stop bits %s, break %s" %
                  (interface, parity, stopbits, breakon))

    def run(self, j):
        self.header()

        # Last wire command (ie non-comment)
        # Used to optionally generate timing
        prevd = None

        for d in j["data"]:
            if d["type"] == "bulkWrite":
                # print(d)
                # json encodes in hex
                # protocol itself encodes in hex
                # data = binascii.unhexlify(d["data"])
                # print(len(data))

                interface = {
                    0x02: 0,
                    0x04: 1,
                }[d["endp"]]

                self.next_json({
                    "type": "write",
                    "interface": interface,
                    "data": d["data"],
                })
            elif d["type"] == "bulkRead":
                assert len(d["data"]) % 2 == 0
                # json encodes in hex
                # protocol itself encodes in hex
                data = binascii.unhexlify(d["data"])
                # print(d)

                interface = {
                    0x81: 0,
                    0x83: 1,
                }[d["endp"]]

                prefix = data[0:2]
                data = data[2:]
                # meh lots of these and not sure what they mean
                # should look into these but just ignore for now
                # assert prefix == "\x42\x60" or prefix == "\x32\x60" or prefix == "\x32\x00", d

                if len(data):
                    self.next_json({
                        "type": "read",
                        "interface": interface,
                        "data": binascii.hexlify(data),
                        "prefix": prefix,
                    })
            elif d["type"] == "controlRead":
                print(d)
                pass
            elif d["type"] == "controlWrite":
                self.handleControlWrite(d)

            # these aren't event added to JSON right now
            # print('%s# WARNING: omitting interrupt' % (indent,))

            prevd = d

        self.footer()
        j = {
            "data": self.jo,
        }
        return j


class JSONSPrinter(object):
    def __init__(self, args):
        self.ascii = args.ascii

    def run(self, j):
        print(json.dumps(j, sort_keys=True, indent=4, separators=(',', ': ')))


class TextSPrinter(object):
    def __init__(self, args):
        self.ascii = args.ascii

    def next_json(self, j, prefix=None):
        if j['type'] == 'read':
            interface = j['interface']
            data = j['data']
            n = len(data) / 2
            prefix = j['prefix']
            if args.ascii:
                indented("%u r %s: %s" %
                         (interface, n, binascii.unhexlify(data)))
            else:
                indented("%u r %s: 0x%s" % (interface, n, data))
                indented("  %s" % (binascii.hexlify(prefix, )))
        elif j['type'] == 'write':
            interface = j['interface']
            data = j['data']
            n = len(data) / 2
            if args.ascii:
                indented("%u w %s: %s" %
                         (interface, n, binascii.unhexlify(data)))
            else:
                indented("%u w %s: 0x%s" % (interface, n, data))
        else:
            assert 0

    def comment(self, s):
        indented('%s' % (s, ))

    def header(self):
        self.comment("Generated by usbrply-serial FT2232C")

    def footer(self):
        pass

    def run(self, j):
        self.header()

        for d in j["data"]:
            self.next_json(d)

        self.footer()


class PythonSPrinter(object):
    def __init__(self, args):
        self.ascii = args.ascii
        self.wrapper = args.wrapper

    def next_json(self, j, prefix=None):
        if j['type'] == 'read':
            interface = j['interface']
            data = binascii.unhexlify(j["data"])
            indented("buff = ser%u.read(%u)" % (interface, len(data)))
            indented("validate_read(%s, buff, \"%s\")" %
                     (bytes2AnonArray(data), "packet"))
        elif j['type'] == 'write':
            data_str = bytes2AnonArray(binascii.unhexlify(j["data"]))
            interface = j['interface']
            indented("ser%u.write(%s)" % (interface, data_str))
        else:
            assert 0

    def comment(self, s):
        indented('# %s' % (s, ))

    def header(self):
        if not self.wrapper:
            return
        # self.comment("Generated by usbrply-serial FT2232C")
        print('''
#!/usr/bin/env python3
import binascii
import time
import serial

def validate_read(expected, actual, msg):
    if expected != actual:
        print('Failed %s' % msg)
        print('  Expected; %s' % binascii.hexlify(expected,))
        print('  Actual:   %s' % binascii.hexlify(actual,))
        #raise Exception('failed validate: %s' % msg)

''')
        print('def replay(ser0):')
        indent_inc()

    def footer(self):
        indent_dec()
        if not self.wrapper:
            return
        print('''
if __name__ == "__main__":
    import argparse 
    
    parser = argparse.ArgumentParser(description='Replay captured USB-serial packets')
    parser.add_argument('-p',
                        "--port",
                        default="/dev/ttyUSB0",
                        help="")
    args = parser.parse_args()

    serial0 = serial.Serial(
        args.port,
        baudrate=115200,
        bytesize=serial.EIGHTBITS,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        rtscts=False,
        dsrdtr=False,
        xonxoff=False,
        timeout=0,
        writeTimeout=None)
    replay(serial0)

''')

    def run(self, j):
        self.header()

        for d in j["data"]:
            self.next_json(d)

        self.footer()


import argparse
import usbrply.parsers
from usbrply.util import add_bool_arg

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Decode USB-serial data')
    parser.add_argument('--range', '-r', help='inclusive range like 123:456')
    parser.add_argument('--verbose', '-v', action='store_true', help='verbose')
    add_bool_arg(
        parser,
        '--sleep',
        default=False,
        help='Insert sleep statements between packets to keep original timing')
    add_bool_arg(parser, '--comment', default=False, help='General comments')
    add_bool_arg(parser, '--ascii', default=False, help='Print as ASCII')
    parser.add_argument('-p',
                        dest='ofmt',
                        default='libusb-py',
                        action='store_const',
                        const='libusb-py',
                        help='output libusb python')
    parser.add_argument('-t',
                        dest='ofmt',
                        action='store_const',
                        const='text',
                        help='output text')
    parser.add_argument('-j',
                        dest='ofmt',
                        action='store_const',
                        const='json',
                        help='output json')
    parser.add_argument('--device',
                        type=int,
                        default=None,
                        help='Only keep packets for given device')
    parser.add_argument('--device-hi',
                        action='store_true',
                        help='Auto detect to highest device number')
    parser.add_argument('--vid', default='0')
    parser.add_argument('--pid', default='0')
    parser.add_argument('fin', help='File name in')
    parser.add_argument('-w', action='store_true', help='Write python file')

    parser.add_argument(
        '--parser',
        default="auto",
        help='Which parser engine to use. Choices: auto, lin-pcap, win-pcap')
    add_bool_arg(
        parser,
        '--setup',
        default=False,
        help='Emit initialization packets like CLEAR_FEATURE, SET_FEATURE')
    add_bool_arg(parser, '--wrapper', default=False, help='')
    add_bool_arg(parser, '--fx2', default=False, help='FX2 comments')
    add_bool_arg(parser,
                 '--rel-pkt',
                 default=False,
                 help='Only count kept packets')
    add_bool_arg(parser,
                 '--packet-numbers',
                 default=True,
                 help='print packet numbers')
    add_bool_arg(parser,
                 '--remoteio',
                 default=False,
                 help='Warn on -EREMOTEIO resubmit (default: ignore)')
    add_bool_arg(
        parser,
        '--print-short',
        default=False,
        help='Print warning when request returns less data than requested')

    args = parser.parse_args()

    vid = int(args.vid, 0)
    pid = int(args.pid, 0)

    if args.range:
        (g_min_packet, g_max_packet) = args.range.split(':')
        if len(g_min_packet) == 0:
            g_min_packet = 0
        else:
            g_min_packet = int(g_min_packet, 0)
        if len(g_max_packet) == 0:
            g_max_packet = float('inf')
        else:
            g_max_packet = int(g_max_packet, 0)

    parser = FT2232CParser
    printer = {
        'text': TextSPrinter,
        'libusb-py': PythonSPrinter,
        'json': JSONSPrinter,
    }[args.ofmt]

    if args.w:
        filename, file_extension = os.path.splitext(args.fin)
        fnout = filename + '.py'
        print('Selected output file %s' % fnout)
        # assert fnout != args.fin and fnout != json_fn
        assert fnout != args.fin
        fout = open(fnout, 'w')
        sys.stdout = fout

    txtj = parser(args).run(usbrply.parsers.pcap2json(args))
    printer(args).run(txtj)
