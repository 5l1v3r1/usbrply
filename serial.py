#!/usr/bin/env python

from usbrply.printer import Printer, indented, indent_inc, indent_dec
from usbrply.pyprinter import bytes2AnonArray
import sys
import binascii
import json
import os

# is a packet json output format but a serial input format  
class FT2232CParser(Printer):
    def __init__(self, args):
        Printer.__init__(self, args)
        self.ascii = args.ascii
        self.json = args.json
        self.jo = []

    def next_json(self, j, prefix=None):
        self.jo.append(j)

    def header(self):
        # comment("Generated by usbrply-serial FT2232C")
        pass

    def footer(self):
        pass

    def run(self, j):
        self.header()

        # Last wire command (ie non-comment)
        # Used to optionally generate timing
        prevd = None

        for d in j["data"]:
            if d["type"] == "bulkWrite":
                # json encodes in hex
                # protocol itself encodes in hex
                data = binascii.unhexlify(d["data"])
                
                interface = {
                    0x02: 0,
                    0x04: 1,
                    }[d["endp"]]

                self.next_json({
                    "type": "write",
                    "interface": interface,
                        "data": binascii.hexlify(data),
                            })
            elif d["type"] == "bulkRead":
                assert len(d["data"]) %2 == 0
                # json encodes in hex
                # protocol itself encodes in hex
                data = binascii.unhexlify(d["data"])
    
                interface = {
                    0x81: 0,
                    }[d["endp"]]

                prefix = data[0:2]
                data = data[2:]
                # assert prefix == "\x32\x60", binascii.hexlify(prefix)
                assert prefix == "\x42\x60" or prefix == "\x32\x60" or prefix == "\x32\x00", d

                if len(data):
                    self.next_json({
                        "type": "read",
                        "interface": interface,
                        "data": binascii.hexlify(data),
                        "prefix": prefix,
                                })

            # these aren't event added to JSON right now
            # print('%s# WARNING: omitting interrupt' % (indent,))

            prevd = d

        self.footer()
        j = {
            "data": self.jo,
            }
        return j


class JSONSPrinter(object):
    def __init__(self, args):
        self.ascii = args.ascii
        self.json = args.json

    def run(self, j):
        print(json.dumps(j, sort_keys=True, indent=4, separators=(',', ': ')))

class TextSPrinter(object):
    def __init__(self, args):
        self.ascii = args.ascii
        self.json = args.json

    def next_json(self, j, prefix=None):
        if j['type'] == 'read':
            interface = j['interface']
            data = j['data']
            prefix = j['prefix']
            if args.ascii:
                indented("%u r %s: %s" % (interface, len(data), data))
            else:
                indented("%u r %s: 0x%s" % (interface, len(data), binascii.hexlify(data),))
                indented("  %s" % (binascii.hexlify(prefix,)))
        elif j['type'] == 'write':
            interface = j['interface']
            data = j['data']
            if args.ascii:
                indented("%u w %s: %s" % (interface, len(data), data))
            else:
                indented("%u w %s: 0x%s" % (interface, len(data), binascii.hexlify(data),))
        else:
            assert 0


    def comment(self, s):
        indented('%s' % (s, ))

    def header(self):
        self.comment("Generated by usbrply-serial FT2232C")

    def footer(self):
        pass

    def run(self, j):
        self.header()

        for d in j["data"]:
            self.next_json(d)

        self.footer()

class PythonSPrinter(object):
    def __init__(self, args):
        self.ascii = args.ascii
        self.json = args.json
        self.wrapper = args.wrapper

    def next_json(self, j, prefix=None):
        if j['type'] == 'read':
            interface = j['interface']
            data = binascii.unhexlify(j["data"])
            indented(
                "buff = ser%u.read(%u)" %
                (interface, len(data)))
            indented("validate_read(%s, buff, \"%s\")" %
                     (bytes2AnonArray(data), "packet"))
        elif j['type'] == 'write':
            data_str = bytes2AnonArray(binascii.unhexlify(j["data"]))
            interface = j['interface']
            indented("ser%u.write(%s)" % (interface, data_str))
        else:
            assert 0


    def comment(self, s):
        indented('# %s' % (s, ))

    def header(self):
        # self.comment("Generated by usbrply-serial FT2232C")
        print('''
#!/usr/bin/env python3
import binascii
import time
import serial

def validate_read(expected, actual, msg):
    if expected != actual:
        print('Failed %s' % msg)
        print('  Expected; %s' % binascii.hexlify(expected,))
        print('  Actual:   %s' % binascii.hexlify(actual,))
        #raise Exception('failed validate: %s' % msg)

''')
        print('def replay(ser0):')
        indent_inc()

    def footer(self):
        indent_dec()
        if not self.wrapper:
            return
        print('''
if __name__ == "__main__":
    import argparse 
    
    parser = argparse.ArgumentParser(description='Replay captured USB-serial packets')
    parser.add_argument('-p',
                        "--port",
                        default="/dev/ttyUSB0",
                        help="")
    args = parser.parse_args()

    serial0 = serial.Serial(
        args.port,
        baudrate=115200,
        bytesize=serial.EIGHTBITS,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        rtscts=False,
        dsrdtr=False,
        xonxoff=False,
        timeout=0,
        writeTimeout=None)
    replay(serial0)

''')

    def run(self, j):
        self.header()

        for d in j["data"]:
            self.next_json(d)

        self.footer()


import argparse
import usbrply.parsers
from usbrply.util import add_bool_arg

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Decode USB-serial data')
    parser.add_argument('--range', '-r', help='inclusive range like 123:456')
    parser.add_argument('--verbose', '-v', action='store_true', help='verbose')
    add_bool_arg(
        parser,
        '--sleep',
        default=False,
        help='Insert sleep statements between packets to keep original timing')
    add_bool_arg(parser, '--comment', default=False, help='General comments')
    add_bool_arg(parser, '--ascii', default=False, help='Print as ASCII')
    add_bool_arg(parser, '--json', default=False, help='Print serial json')
    parser.add_argument('--device',
                        type=int,
                        default=None,
                        help='Only keep packets for given device')
    parser.add_argument('--device-hi',
                        action='store_true',
                        help='Auto detect to highest device number')
    parser.add_argument('--vid', default='0')
    parser.add_argument('--pid', default='0')
    parser.add_argument('fin', help='File name in')
    parser.add_argument('-w', action='store_true', help='Write python file')

    parser.add_argument(
        '--parser',
        default="auto",
        help='Which parser engine to use. Choices: auto, lin-pcap, win-pcap')
    add_bool_arg(
        parser,
        '--setup',
        default=False,
        help='Emit initialization packets like CLEAR_FEATURE, SET_FEATURE')
    add_bool_arg(
        parser,
        '--wrapper',
        default=False,
        help='')
    add_bool_arg(parser, '--fx2', default=False, help='FX2 comments')
    add_bool_arg(parser,
                 '--rel-pkt',
                 default=False,
                 help='Only count kept packets')
    add_bool_arg(parser,
                 '--packet-numbers',
                 default=True,
                 help='print packet numbers')
    add_bool_arg(
        parser,
        '--print-short',
        default=False,
        help='Print warning when request returns less data than requested')

    args = parser.parse_args()

    vid = int(args.vid, 0)
    pid = int(args.pid, 0)

    if args.range:
        (g_min_packet, g_max_packet) = args.range.split(':')
        if len(g_min_packet) == 0:
            g_min_packet = 0
        else:
            g_min_packet = int(g_min_packet, 0)
        if len(g_max_packet) == 0:
            g_max_packet = float('inf')
        else:
            g_max_packet = int(g_max_packet, 0)

    parser = FT2232CParser
    printer = {
        # False: TextSPrinter,
        False: PythonSPrinter,
        True: JSONSPrinter,
        }[args.json]

    if args.w:
        filename, file_extension = os.path.splitext(args.fin)
        fnout = filename + '.py'
        print('Selected output file %s' % fnout)
        # assert fnout != args.fin and fnout != json_fn
        assert fnout != args.fin
        fout = open(fnout, 'w')
        sys.stdout = fout

    txtj = parser(args).run(usbrply.parsers.pcap2json(args))
    printer(args).run(txtj)


